{"ast":null,"code":"'use strict';\n\nrequire('./es6.regexp.exec');\n\nvar redefine = require('./_redefine');\n\nvar hide = require('./_hide');\n\nvar fails = require('./_fails');\n\nvar defined = require('./_defined');\n\nvar wks = require('./_wks');\n\nvar regexpExec = require('./_regexp-exec');\n\nvar SPECIES = wks('species');\nvar REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {\n  // #replace needs built-in support for named groups.\n  // #match works fine because it just return the exec results, even if it has\n  // a \"grops\" property.\n  var re = /./;\n\n  re.exec = function () {\n    var result = [];\n    result.groups = {\n      a: '7'\n    };\n    return result;\n  };\n\n  return ''.replace(re, '$<a>') !== '7';\n});\n\nvar SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = function () {\n  // Chrome 51 has a buggy \"split\" implementation when RegExp#exec !== nativeExec\n  var re = /(?:)/;\n  var originalExec = re.exec;\n\n  re.exec = function () {\n    return originalExec.apply(this, arguments);\n  };\n\n  var result = 'ab'.split(re);\n  return result.length === 2 && result[0] === 'a' && result[1] === 'b';\n}();\n\nmodule.exports = function (KEY, length, exec) {\n  var SYMBOL = wks(KEY);\n  var DELEGATES_TO_SYMBOL = !fails(function () {\n    // String methods call symbol-named RegEp methods\n    var O = {};\n\n    O[SYMBOL] = function () {\n      return 7;\n    };\n\n    return ''[KEY](O) != 7;\n  });\n  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {\n    // Symbol-named RegExp methods call .exec\n    var execCalled = false;\n    var re = /a/;\n\n    re.exec = function () {\n      execCalled = true;\n      return null;\n    };\n\n    if (KEY === 'split') {\n      // RegExp[@@split] doesn't call the regex's exec method, but first creates\n      // a new one. We need to return the patched regex when creating the new one.\n      re.constructor = {};\n\n      re.constructor[SPECIES] = function () {\n        return re;\n      };\n    }\n\n    re[SYMBOL]('');\n    return !execCalled;\n  }) : undefined;\n\n  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {\n    var nativeRegExpMethod = /./[SYMBOL];\n    var fns = exec(defined, SYMBOL, ''[KEY], function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {\n      if (regexp.exec === regexpExec) {\n        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {\n          // The native String method already delegates to @@method (this\n          // polyfilled function), leasing to infinite recursion.\n          // We avoid it by directly calling the native @@method method.\n          return {\n            done: true,\n            value: nativeRegExpMethod.call(regexp, str, arg2)\n          };\n        }\n\n        return {\n          done: true,\n          value: nativeMethod.call(str, regexp, arg2)\n        };\n      }\n\n      return {\n        done: false\n      };\n    });\n    var strfn = fns[0];\n    var rxfn = fns[1];\n    redefine(String.prototype, KEY, strfn);\n    hide(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)\n    // 21.2.5.11 RegExp.prototype[@@split](string, limit)\n    ? function (string, arg) {\n      return rxfn.call(string, this, arg);\n    } // 21.2.5.6 RegExp.prototype[@@match](string)\n    // 21.2.5.9 RegExp.prototype[@@search](string)\n    : function (string) {\n      return rxfn.call(string, this);\n    });\n  }\n};","map":{"version":3,"sources":["C:/Users/chris/Documents/GitHub/ResumeWebSite/Newsite/resume/node_modules/babel-polyfill/node_modules/core-js/modules/_fix-re-wks.js"],"names":["require","redefine","hide","fails","defined","wks","regexpExec","SPECIES","REPLACE_SUPPORTS_NAMED_GROUPS","re","exec","result","groups","a","replace","SPLIT_WORKS_WITH_OVERWRITTEN_EXEC","originalExec","apply","arguments","split","length","module","exports","KEY","SYMBOL","DELEGATES_TO_SYMBOL","O","DELEGATES_TO_EXEC","execCalled","constructor","undefined","nativeRegExpMethod","fns","maybeCallNative","nativeMethod","regexp","str","arg2","forceStringMethod","done","value","call","strfn","rxfn","String","prototype","RegExp","string","arg"],"mappings":"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","sourcesContent":["'use strict';\r\nrequire('./es6.regexp.exec');\r\nvar redefine = require('./_redefine');\r\nvar hide = require('./_hide');\r\nvar fails = require('./_fails');\r\nvar defined = require('./_defined');\r\nvar wks = require('./_wks');\r\nvar regexpExec = require('./_regexp-exec');\r\n\r\nvar SPECIES = wks('species');\r\n\r\nvar REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {\r\n  // #replace needs built-in support for named groups.\r\n  // #match works fine because it just return the exec results, even if it has\r\n  // a \"grops\" property.\r\n  var re = /./;\r\n  re.exec = function () {\r\n    var result = [];\r\n    result.groups = { a: '7' };\r\n    return result;\r\n  };\r\n  return ''.replace(re, '$<a>') !== '7';\r\n});\r\n\r\nvar SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {\r\n  // Chrome 51 has a buggy \"split\" implementation when RegExp#exec !== nativeExec\r\n  var re = /(?:)/;\r\n  var originalExec = re.exec;\r\n  re.exec = function () { return originalExec.apply(this, arguments); };\r\n  var result = 'ab'.split(re);\r\n  return result.length === 2 && result[0] === 'a' && result[1] === 'b';\r\n})();\r\n\r\nmodule.exports = function (KEY, length, exec) {\r\n  var SYMBOL = wks(KEY);\r\n\r\n  var DELEGATES_TO_SYMBOL = !fails(function () {\r\n    // String methods call symbol-named RegEp methods\r\n    var O = {};\r\n    O[SYMBOL] = function () { return 7; };\r\n    return ''[KEY](O) != 7;\r\n  });\r\n\r\n  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {\r\n    // Symbol-named RegExp methods call .exec\r\n    var execCalled = false;\r\n    var re = /a/;\r\n    re.exec = function () { execCalled = true; return null; };\r\n    if (KEY === 'split') {\r\n      // RegExp[@@split] doesn't call the regex's exec method, but first creates\r\n      // a new one. We need to return the patched regex when creating the new one.\r\n      re.constructor = {};\r\n      re.constructor[SPECIES] = function () { return re; };\r\n    }\r\n    re[SYMBOL]('');\r\n    return !execCalled;\r\n  }) : undefined;\r\n\r\n  if (\r\n    !DELEGATES_TO_SYMBOL ||\r\n    !DELEGATES_TO_EXEC ||\r\n    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||\r\n    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)\r\n  ) {\r\n    var nativeRegExpMethod = /./[SYMBOL];\r\n    var fns = exec(\r\n      defined,\r\n      SYMBOL,\r\n      ''[KEY],\r\n      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {\r\n        if (regexp.exec === regexpExec) {\r\n          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {\r\n            // The native String method already delegates to @@method (this\r\n            // polyfilled function), leasing to infinite recursion.\r\n            // We avoid it by directly calling the native @@method method.\r\n            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };\r\n          }\r\n          return { done: true, value: nativeMethod.call(str, regexp, arg2) };\r\n        }\r\n        return { done: false };\r\n      }\r\n    );\r\n    var strfn = fns[0];\r\n    var rxfn = fns[1];\r\n\r\n    redefine(String.prototype, KEY, strfn);\r\n    hide(RegExp.prototype, SYMBOL, length == 2\r\n      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)\r\n      // 21.2.5.11 RegExp.prototype[@@split](string, limit)\r\n      ? function (string, arg) { return rxfn.call(string, this, arg); }\r\n      // 21.2.5.6 RegExp.prototype[@@match](string)\r\n      // 21.2.5.9 RegExp.prototype[@@search](string)\r\n      : function (string) { return rxfn.call(string, this); }\r\n    );\r\n  }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}